# 常见的 package.json 的配置

-   npm 官方文档文档地址： https://docs.npmjs.com/cli/v10/configuring-npm/package-json
-   Node.js 官方文档 (模块解析机制)：https://nodejs.org/api/packages.html
-   3 种产物指定入口配置：

```js
{
  "name": "my-ui-library",
  "version": "1.0.0",
  // 1. 类型定义入口 (必须指向 .d.ts)
  "types": "./dist/index.d.ts",

  // 2. CJS 入口 (兼容老旧环境)：https://docs.npmjs.com/cli/v10/configuring-npm/package-json#main
  "main": "./dist/index.cjs",

  // 3. ESM 入口 (兼容不支持 exports 的打包工具)
  "module": "./dist/index.js",

  // 4. IIFE 入口 (给 CDN 用)
  "unpkg": "./dist/index.iife.js",
  "jsdelivr": "./dist/index.iife.js",

  // 5. 现代入口配置 (最高优先级:一般不配置
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",  // TS 类型
      "import": "./dist/index.js",   // 遇到 import 语句，用 ESM
      "require": "./dist/index.cjs"  // 遇到 require 语句，用 CJS
    },
    // 如果你允许用户引入 CSS
    "./style.css": "./dist/style.css"
  },

  // 指定发布到 npm 的文件白名单
  "files": [
    "dist"
  ]
}

```

# 使用@lcllcllcl/ui

1. 方法 1：

-   使用 workspace 创建软连接，连接@miaoma/ui：可以在 node_modules 中查看

```js
import { Button } from '@lcllcllcl/ui'
```

默认会去 node_modules/@lcllcllcl/ui/package.json 中寻找入口文件（main、module、type），然后根据入口文件设置的路径去寻找资源

> 场景一：用户在 Vite/Next.js 项目中开发 (ESM)
> 代码： import { Button } from 'my-ui-library';
> 流程：
> Vite 读取 package.json。
> 发现 exports 字段。
> 匹配 import 条件。
> 结果： 加载 ./dist/index.js (ESM)。
> 收益： 成功 Tree-shaking，只打包了 Button 的代码。

-   打包@miaoma/ui，产生需要的静态资源

2. 进阶解决方法 2：适用于开发环境：

-   使用 workspace 创建软连接，连接@miaoma/ui：可以在 node_modules 中查看
-   将包名直接映射到@miaoma/ui 源码入口： [vite.config.ts](apps/use-ui/vite.config.ts)

```js
'@lcllcllcl/ui': path.resolve(__dirname, '../../packages/ui/src/index.ts')
```

> 这样做的收益：
>
> -   无需构建： 开发时直接消费 TS 源码。
> -   实时调试： console.log 或断点直接打在源码里，而不是压缩后的代码里。

-   打包工具搞定，下面配置 TS 编译器，TS 编译器默认不会像 Vite 那样去读 Alias，所以会找不到路劲：配置 paths、与 include：[tsconfig.app.json](tsconfig.app.json)

# tsup rollup、vite 常见的打包配置(后面了解 )

> 遇到了在查看文档问 ai

-   tsup: https://tsup.egoist.dev/#multiple-entrypoints
    [tsconfig.json](packages/ui/tsconfig.json)

# 状态管理

-   笔记：https://my.feishu.cn/docx/CEQcd7dgyoMwhjxD9Y6cC3RDn9a
-   Mantine UI 内部自实现的集中状态管理：（学习）https://github.com/mantinedev/mantine/blob/master/packages/%40mantine/store/src/store.ts
-   官网 useSyncExternalStore：https://zh-hans.react.dev/reference/react/useSyncExternalStore

    -   代码：[code](apps/use-ui/src/01.learn-useSyncExternalStore)

# 初步认识 vitest: [text](packages/ui/vitest.md)

# Turbo

1. 官网：https://turbo.nodejs.cn/docs/crafting-your-repository/managing-dependencies
2. 任务配置：[text](turbo.json)

3. 理解 dependsOn：是 Turborepo 用来 控制任务执行顺序 的配置项；在运行某个任务之前，需要先运行哪些其他任务

-   依赖自身包内的任务:用来控制 同一个包里脚本的顺序。
    > 例如：想要在同一个包里：先执行 build，再执行 test

```json
// 当 Turborepo 运行 test 时，会先执行这个包里的 build 脚本，再执行 test
{
    "tasks": {
        "test": {
            "dependsOn": ["build"]
        }
    }
}
```

-   依赖其他包的任务 — 使用 ^ 前缀。

> 例如：通常在 monorepo 中，我们有：apps/web → 依赖 packages/ui
> 你想让：先执行 packages/ui 的 build;再执行 apps/web 的 build

```json
// ^build 告诉 Turborepo：“先运行所有依赖包里的 build 任务，再运行当前包的 build”: packages/ui#build → apps/web#build
{
    "tasks": {
        "build": {
            "dependsOn": ["^build"]
        }
    }
}
```

-   依赖某个具体包里的某个任务: 有时不是全部依赖，而是特定某个包的某个任务。
    > 例子:你有一个 utils 包，它有 build。你希望所有其它包运行 lint 之前：先运行 utils 的 build

```json
// 这里的 utils#build 就是 “utils 包的 build 任务必须先执行完”，才能运行后面的 lint
{
    "tasks": {
        "lint": {
            "dependsOn": ["utils#build"]
        }
    }
}
```

4. 配置启动命令

-   不使用 turbo:

```json
"myWebsite:build": "pnpm --filter my-website build",
"ui:build": "pnpm --filter @lcllcllcl/ui build",
"my:build:pnpm": "pnpm ui:build &&  pnpm myWebsite:build",
```

-   使用 turbo:
    [turbo.json 配置：](turbo.json)

```json
// build的时候只会执行my-website的build, 因为有 ^build，它会自动把 @lcllcllcl/ui（以及更多上游依赖）一起 build。
 "my:build": "turbo run build  --filter=my-website",
//  预览地址：https://dreampuf.github.io/GraphvizOnline/
 "my:build:graph": "turbo run build  --filter=my-website --graph"
```

    把运行的graph代码复制到这个网站上：

![alt text](img/graph.png)

# nrm

    作用类似nvm：https://github.com/Pana/nrm

```js
npm install -g nrm
nrm ls
nrm use
nrm add

```

# npm 发包：

1. 组件库发布：npm 仓库、阿里云效平台的制平台`（本次使用）`、Npm 私服搭建：https://verdaccio.org/zh-cn/

2. npm 双 token 验证的限制 np 用不了，可以不让 np 发包。让 np 完成打包、测试、打版本号、打 tag 就行，然后手动配置 npm publish

> semantic release 后面学 ci/cd 在试试。

3. 发包配置

-   publishConfig 配置发包的信息：[publishConfig](packages/ui/package.json)
-   配置 npm 登录、资源下载的 registry 配置：[npmrc](packages/ui/.npmrc)
-   配置发哪些包 files： [files](packages/ui/package.json)

# 解决发包流程:np

> npm 包的版本管理+ tag 版本管理 + 自动生成日志

1. 设计之初就是为了`单仓库`（Single-Package Repo）的高效发布。
2. np 的核心缺点：上下文脱节

-   路径隔离导致的 Git 状态冲突：
    在 Monorepo 项目中，子包执行：np 会在当前目录（子包）找 package.json 并执行 version。但它在最后一步打 tag 和 commit 时，通常会尝试在根目录进行 Git 操作。如果子包和根目录的 Git 状态不一致（比如根目录有未提交的改动），np 经常会报错退出,不会执行 commit
    忽略全局依赖：在子包执行时，它无法感知 Monorepo 的全局依赖锁（如 pnpm-lock.yaml），导致 npm install 阶段可能破坏锁文件。
-   Version 命令失效：
    在根目录执行：np 默认只处理根目录的 package.json。在 Monorepo 根目录下执行 np，它只会提升根目录的版本号，而不会去遍历 packages/\* 下的子包。就无法触发 npm 的的生命周期钩子函数（`version`）.缺乏 Workspace 意识：它不会自动运行 pnpm recursive 或类似的命令来同步工作区依赖版本。

3. 常用的配置：执行测试-> 自动生成版本(选则版本) -> 执行 version 周期命令 -> push tag -> build -> publish -> commit

```js
"scripts": {
        "release": "np --otp",
        "release:preview": "np --preview",
        "release:noTests": "np --no-tests",
        "changelog": "conventional-changelog -p conventionalcommits -i CHANGELOG.md -s",
        "changelog:init": "conventional-changelog -p conventionalcommits -i CHANGELOG.md -s -r 0",
        "version": "conventional-changelog -p conventionalcommits -i CHANGELOG.md -s && git add CHANGELOG.md",
        // 手动publish，然后npm的双token安全验证
        "release:ui": "pnpm run test && np --no-publish --no-tests && pnpm run build && pnpm publish",
        "changelog": "conventional-changelog -p conventionalcommits -i CHANGELOG.md -s"
    },
    "np": {
        "packageManager": "pnpm",
        "private": false,
        "cleanup": false,
        "tests": false,
        "yarn": false,
        "2fa": false,
        "message": "feat: 发布%s版本",
        "hooks": {
            // 自动生成日志
            "version": "pnpm run changelog && git add ."
        }
    },
```

# 自动获取 git 提交日志：

    1. np 来管理版本发布，我建议使用 conventional-changelog-cli

    - 安装：pnpm add -D conventional-changelog-cli
        > - conventional-changelog-cli - 轻量级 CLI，只生成 CHANGELOG

    2. 添加 npm scripts

    - pnpm changelog - 增量更新 changelog
    - pnpm changelog:init - 生成完整 changelog
    - pnpm version - 与 git 集成的版本钩子

    3. 创建配置文件

    - conventional-changelog-cli(不生效)
    - 自定义 changelog 生成规则，添加了 emoji：[changelogrc](packages/ui/.changelogrc.js)

    4. 集成 np

    - 版本自动化管理：git 的 tag 与包的版本
    - 配置 np 钩子，在发布时自动生成 changelog:

```js
"np": {
        "packageManager": "pnpm",
        "cleanup": false,
        "tests": true,
        "yarn": false,
        "hooks": {
            "version": "pnpm version && git add CHANGELOG.md"
        }
    },
```

-   缺点：

5. 更新 npm 发包文件

```js
 "files": [
        "esm-dist",
        "iife-dist",
        "cjs-dist",
        "CHANGELOG.md"
    ],
```

6. 常见的配置：[配置](packages/ui/package.json)
    - 常用 npx conventional-changelog -p angular -i CHANGELOG.md -s -r 0
    - 参数详细解释

```js
-p angular (Preset)
    含义：指定预设规范。
    解释：告诉工具如何解析 Git 提交信息。angular 是最常用的规范（要求提交格式为 feat: ... 或 fix: ...）。如果你用的是 conventionalcommits 规范，可以换成 -p conventionalcommits。
-i CHANGELOG.md (Infile)
    含义：指定输入文件。
    解释：工具会先读取这个文件里的旧内容，然后把新生成的日志插入到最前面。如果文件不存在，它会自动创建一个。
-s (Same File)
    含义：写回原文件。
    解释：如果不加这个参数，生成的日志只会打印在终端（stdout）。加上 -s 后，它会直接更新 CHANGELOG.md。
-r 0 (Release Count)
    含义：生成多少个版本的日志。
    解释：
    -r 1（默认）：只生成从“上一个 tag”到“现在”的增量日志。
    -r 0：生成从项目第一条提交到现在的所有版本的日志。
    为什么常用 -r 0：在第一次初始化项目日志，或者发现之前的日志有错位需要重刷全量时，这是必用的命令。

进阶：Monorepo (如 @packages/ui) 常用命令:对于你关心的子包场景，通常会加上路径过滤和 Tag 前缀：
npx conventional-changelog -p angular -i CHANGELOG.md -s --commit-path packages/ui --tag-prefix "@packages/ui@"
    -commit-path packages/ui：核心参数。强制工具只计算影响 packages/ui 目录的 Git 提交。
    --tag-prefix "@packages/ui@"：告诉工具这个包的 Tag 格式。例如你的 Tag 是 @packages/ui@1.0.0，如果不配置前缀，工具可能识别不到上一个版本在哪里。
```

6 总结:

-   日常更新增量：npx conventional-changelog -p angular -i CHANGELOG.md -s
-   第一次生成全量：npx conventional-changelog -p angular -i CHANGELOG.md -s -r 0
-   子包增量生成：npx conventional-changelog -p angular -i CHANGELOG.md -s --commit-path packages/ui --tag-prefix "@packages/ui@"

# 解决发包流程:@changesets/cli

1. 为什么选择 Changesets？
   ` 针对 Monorepo 设计`：能自动识别哪些包有变动，并处理包之间的版本依赖（例如 ui 更新版本后，依赖它的 web 包也会被标记）。
   交互式选择：执行 npx changeset 时会提示你选择版本类型（patch/minor/major）并输入变更信息。
   标准发布流：它将版本更新（version）和代码发布（publish）解耦，非常适合 CI/CD 环境。
   支持 pnpm：原生支持 pnpm-workspace.yaml。

    - https://www.npmjs.com/package/@changesets/cli

2. 发布流程：执行测试-> 自动生成版本(选则版本、填写日志等) -> build -> publish -> push tag -> commit
3. Changesets 在选择版本变化后：会手动填写日志
   | 维度 | @changesets/cli | conventional-changelog-cli|
   |-----|-----|-----|
   |内容来源 | 开发者针对每个 changeset 手写的描述 | 自动提取的 Git Commit 标题/正文 |
   | 灵活性 |极高。你可以为一个功能写多个变更描述，或者合并多个 Commit 只写一个描述。 | 较低。Changelog 几乎就是 Git 历史的镜像。 |
   |面向对象 | 开发者针对每个 changeset 手写的描述 | 面向开发者（记录做了哪些代码修改）。 |
   |颗粒度 | 以“变更意图”为单位。 | 以“代码提交”为单位 |
4. 典型应用场景建议：

    - 使用 @changesets/cli 如果：
        - 你的项目是复杂的 Monorepo（如 pnpm workspaces）。
        - 你希望 Changelog 的质量更高、更易于非开发人员阅读。
        - 你希望更精细地控制版本发布逻辑（如预发布版本、复杂的依赖更新）。
    - 使用 conventional-changelog-cli 如果：
        - 你的团队已经有非常完美的 Commit 规范（如通过 commitlint 强制执行）。
        - 你追求极致的自动化，不想在提交代码时再多走一步手写 changeset 的流程。
        - 你的 Monorepo 结构相对简单，或者你已经在用 Lerna 等老牌工具。
    - 总结： changesets 是在提交时记录意图，conventional-changelog 是在发布时追溯历史。在现代前端 Monorepo（如 Vite、Next.js、Turbo）中，@changesets/cli 目前更受青睐。

5. 使用阿里云效平台的制平台发包

-   https://packages.aliyun.com/npm/npm-registry/guide?appId=5e8438543bb69373660679e2
-   https://packages.aliyun.com/npm/npm-registry/guide
    > 记得更换 npm 登录、上传、下载的地址

6. 使用：@changesets/cli

-   文档：https://github.com/changesets/changesets/tree/main
-   使用： https://github.com/changesets/changesets/blob/main/docs/intro-to-using-changesets.md
-   常用命令：[changesets](package.json)
-   配置项：[t.changesett](.changeset)
-   pnpm run ui:release 为发包命令；发包前需要 git 的日志记录：需要运行 ui 库的 pnpm run gitCommitAllLog 命令

```json
    "ui:version": "changeset & changeset version && pnpm install",
    "ui:publish": "pnpm --filter @lcllcllcl/ui publish --no-git-checks",
    "ui:tag": "node scripts/ui-tag.cjs",
    "ui:release": "pnpm --filter @lcllcllcl/ui test && pnpm ui:version && pnpm ui:publish && pnpm ui:tag && pnpm commit "
```

# CICD 发站点包：后面搞

<!-- -----------asdasdasd------ -->

vscode 的插件怎么提示安装库、有哪些版本
发布：
npm 的生命周期

<!-- ------需要实现的任务-------- -->
